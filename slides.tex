\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{minted}
\usepackage{comment}
%\usepackage{graphics}
\usepackage{graphicx}
%https://tex.stackexchange.com/questions/365292/how-to-use-non-ascii-chars/365303#365303
\usepackage{pmboxdraw}

\newenvironment{code}{\VerbatimEnvironment \begin{minted}{haskell}}{\end{minted}}
\newenvironment{ascii}{\VerbatimEnvironment \begin{minted}{text}}{\end{minted}}
\newcommand{\hsmint}[1]{\mintinline{haskell}{#1}}

\begin{document}


\title{Probablistic Programming: Use cases and implementation}
\author{Siddharth Bhat}
\institute{IIIT Hyderabad}
\date{\today\par (FunctionalConf '19)}

\begin{frame}[fragile]
\titlepage
\end{frame}

\begin{frame}[fragile]{Our primitives}
\begin{code}
-- | Convert a pure value into a Rand value
return :: a -> Rand a

-- | Get a random number
uniform01 :: Rand Float

-- | Take `n` samples from a random variable
samples :: Int -> Rand a -> [a]

-- | take a Float, do *something*, and return nothing
score :: Float -> Rand ()
\end{code}



\end{frame}


\begin{frame}[fragile]{First example -- The same as \hsmint{System.Random}}
\begin{columns}
\column{0.5\linewidth}
\begin{code}
-- | dice
dice :: Rand Int
dice = do
  u <- uniform01
  return $ floor (7*u)
\end{code}

\column{0.5\linewidth}
\begin{code}
-- | sum of dice
tossDice :: Rand Int
tossDice = do
    d1 <- dice
    d2 <- dice
    return $ d1 + d2
\end{code}
\end{columns}

\begin{code}
main :: IO ()
main = do
  print $ sample 10 tossDice
  drawHistogram $ sample 100 tossDice
\end{code}

\textbf{Output:}
\input{"| cabal v2-exec slides -- tossDice"}
\end{frame}


\begin{frame}[fragile]{Raytracing (Default)}
\begin{columns}
\column{0.2\linewidth}
        \includegraphics[height=180px]{res/raytrace.pdf}
\column{0.6\linewidth}
{\scriptsize
\begin{code}
  -- | recursively raytrace
  raytrace :: Ray -> Rand Color
  raytrace r = do
    case getCollision r of
      Some (surface, loc) -> 
       color' <- averageRays loc
       return $ mixColor surface color'
      None -> return backgroundColor

  -- | Send a random ray 
  sendRandRay :: Position -> Rand Color
  sendRandRay p =
    u <- uniform01
    let angle = 360 * u
    raytrace (makeRay p angle)

  -- | Average rays sent from a location
  averageRays :: Position -> Rand Color
  averageRays p = do
    -- | computationally wasteful
    colors <- replicateM 100 (sendRandRay p)
    return $ averageColors colors

  -- | Default background color.
  backgroundColor = white
\end{code}
}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Raytracing (Scored)}
\begin{columns}
\column{0.5\linewidth}
{\scriptsize
\begin{code}
  raytrace :: Ray -> Rand Color
  raytrace r = do
    case getCollision r of
      Some (surface, loc) -> 
       color' <- averageRays loc
       return $ mixColor surface color'
      None -> return backgroundColor
\end{code}
}

\includegraphics[height=180px]{res/raytrace.pdf}
\column{0.5\linewidth}
{\scriptsize
\begin{code}
  raytrace' :: Ray -> Rand Color
  raytrace' r = do
    case getCollision r of
      Some (surface, loc) -> 
       color' <- averageRays loc
       return $ mixColor surface color'
      None -> do
        score 0.5 -- New! 
        return backgroundColor
\end{code}
}
\includegraphics[height=180px]{res/raytrace-scored.pdf}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Exploring a complicated landscape}

\begin{code}
-- | Naive understanding / Little knowledge when we begin
prior :: Rand a
prior = ...

-- | Learn as you go!
learn :: Rand a
learn = do
  value <- prior
  score (usefulness value)
  return value

-- | Generate samples according to unknown distribution
-- (Rays from the raytracing)
landscape :: [a]
landscape = samples 1000 learn

\end{code}
\end{frame}

\begin{frame}[fragile]{Program optimisation}
\begin{columns}
\column{\linewidth}
{\scriptsize \footnotesize
\begin{code}
-- | Randomly change programs and return their performance
equivRandomProgram :: Program -> Rand (Performance, Program)
equivRandomProgram p = do
  p' <- modifyProgram p
  if semanticsEqual p p'
  then return (performance p', p')
  else return (0, p') -- A program that does not work has 0 perf.

-- | Take the random samples and pick the good performing ones
optimise :: Program -> Program
optimise p = 
  let ps' = sample 100 (equivRandomProgram p)
  in snd $ maximumBy (\a b -> compare (fst a) (fst b)) ps'
\end{code}
}
\end{columns}
\end{frame}


\begin{frame}[fragile]{Program optimisation (Scored)}
\begin{columns}
\column{\linewidth}
{\scriptsize \footnotesize
\begin{code}
equivRandomProgram' :: Program -> Rand (Performance, Program)
equivRandomProgram' p = do
 (perf, p) <- equivRandomProgram p
 let perf = 
    if semanticsEqual p p'
      then performance p'
      else 0
 score perf -- ^ Correct programs are more likely
 return (perf, p')

equivRandomProgram :: Program -> Rand (Performance, Program)
equivRandomProgram p = do
  p' <- modifyProgram p
  if semanticsEqual p p'
  then return (performance p', p')
  else return (0, p') -- A program that does not work has 0 perf.
\end{code}
}

{\scriptsize \tiny
    \texttt{http://stoke.stanford.edu/}\qquad
    \texttt{https://github.com/bollu/blaze/blob/master/notebooks/tutorial.ipynb}
}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Use case: Transformations discovered by \texttt{STOKE}}
\begin{columns}
\column{\linewidth}
{\scriptsize
\begin{itemize}
\item
\begin{ascii}
f = 2 + 3
(nparams: 0 | [IPush 2,IPush 3,IAdd])
\end{ascii}
\pause
\begin{ascii}
[IPush 5] | score: 2.5
// constant folding: 2 + 3 -> 5
\end{ascii}
\pause

\item
\begin{ascii}
f(x) = 2 * x
(nparams: 1 | [IPush 2,IMul])
\end{ascii}
\pause
\begin{ascii}
[IDup,IAdd] | score: 2.25 
// strength reduction: 2 * x -> x + x
\end{ascii}
\pause

\item
\begin{ascii}
f(x) = x & x
(nparams: 1 | progInsts = [IDup,IAnd])
\end{ascii}
\pause
\begin{ascii}
[] | score: 3.0
// algebraic rewrite: x & x == x
\end{ascii}
\end{itemize}
}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Optimisation on a complicated landscape}

\begin{code}
-- | Naive understanding / Little knowledge when we begin
prior :: Rand a
prior = ...

-- | Learn as you go!
learn :: Rand (Score, a)
learn = do
  value <- prior
  let s = score (usefulness value)
  return (s, value)

-- | Sample and pick best value (random programs)
-- | Works because sampler will "move" towards 
-- scored regions!
best :: (Score, a)
best = maximumBy (\a b -> compare (fst a) (fst b))
        (samples 1000 learn)
\end{code}

\end{frame}



\begin{frame}[fragile]
\begin{code}
data Rand x where
    Ret :: x -> Rand x
    SampleUniform01 :: (Double -> Rand x) -> Rand x
    Score :: Double -> Rand x -> Rand x


instance Functor Rand
instance Applicative Rand
instance Monad Rand

\end{code}
(\hsmint{Rand} is a free monad)
\end{frame}

\begin{frame}[fragile]
\begin{code}
-- | Run the computation _unweighted_,
-- | ignores scores.
sample :: RandomGen g => g -> Rand a -> (a, g)
sample g (Ret a) = (a, g)
sample g (SampleUniform01 f2my) =
  let (f, g') = random g in sample g' (f2my f)
sample g (Score f mx) = sample g mx -- Ignore score
\end{code}
\end{frame}

\begin{frame}[fragile]{MCMC methods}
\end{frame}


\begin{frame}[fragile]{Traced Computations - Program}
\includegraphics[height=280px]{res/program-1.pdf}
\end{frame}

\begin{frame}[fragile]{Traced Computations - Trace 1}
\includegraphics[height=280px]{res/program-2.pdf}
\end{frame}


\begin{frame}[fragile]{Traced Computations - Trace 2}
\includegraphics[height=280px]{res/program-3.pdf}
\end{frame}

\begin{frame}[fragile]{Tracing: the data structure}
\begin{columns}
\column{\linewidth}
{
\begin{code}
-- | Trace all random choices made
data Trace a =
  Trace { tval :: a, -- ^ The value itself
          tscore :: Double, -- ^ The total score
          trs :: [Double] -- ^ The random numbers used
        }

-- | Trace a random computation.
traceR :: Rand x -> Rand (Trace x)
traceR (Ret x) = Ret (Trace x 1.0 [])
traceR (SampleUniform01 mx) = do
  r <- sample01
  trx <- traceR $ mx r
  return $ trx { trs=trs  ++ [r]}
traceR (Score s mx) = do
  trx <- traceR $ mx
  return $ trx { tscore = tscore*s}
\end{code}
}
\end{columns}
\end{frame}


\begin{frame}[fragile]{Metropolis Hastings}
\begin{code}
mhStep :: Rand (Trace x) -- ^ proposal
         -> Trace x -- ^ current position
         -> Rand (Trace x) -- ^ new
mhStep r trace = do
  -- | Return the original randomness, perturbed
  rands' <- perturbRandomness (trs trace)
  -- | Run the original computation with the perturbation
  trace' <- feedRandomness rands' r
  let ratio = trAccept trace' / trAccept trace
  r <- sample01
  return $ if r < ratio then trace' else trace
\end{code}
  
\begin{columns}
\column{0.5\linewidth}
{\scriptsize
\begin{code}
trAccept :: Trace x -> Double
trAccept tx =
  tscore tx * 
  fromIntegral (length (trs tx))
\end{code}
}
\column{0.5\linewidth}
{\scriptsize
\begin{code}
perturbRandomness :: [Double] 
  -> Rand [Double]
perturbRandomness rands = do
  -- | Random index
  ix <- choose [0..(length rands-1)]
  r <- sample01 -- ^ random val
  -- | Replace random index
  -- with random val.
  return $ replaceListAt ix r rands 
\end{code}
}
\end{columns}
\end{frame}

\begin{frame}[fragile]{Odds and Ends}
\begin{columns}
\column{\linewidth}
{\scriptsize
\begin{code}
-- | run the computatation after taking weights into account
samples :: Int -> Rand x -> Rand [x]
samples 0 _ = return []
samples n r =
  let tracedR = traceR r
      -- go :: Int -> Rand (Trace x) -> Rand (Trace [x])
      go 0 _ = return []
      go n tx = do
        tx' <- repeatM 10 (mhStep tracedR) $ tx -- !
        txs <- go (n-1) tx'
        return (tx:txs)
  in do
      seed <- findNonZeroTrace $ tracedR
      tracedRs <- go n seed 
      return $ map tval tracedRs
\end{code}
}
\end{columns}

\begin{columns}
\column{\linewidth}
{\scriptsize
\begin{code}
-- | Find a starting position that does not have probability 0
findNonZeroTrace :: Rand (Trace x) -> Rand (Trace x)
findNonZeroTrace tracedR = do
  trace <- tracedR
  if tscore trace /= 0
  then return $ trace
  else findNonZeroTrace tracedR
\end{code}
}
\end{columns}

\end{frame}


\begin{frame}[fragile]{Thank you!}
  \begin{beamercolorbox}[center]{title}
    Questions?
  \end{beamercolorbox}





  \vfill
  \begin{beamercolorbox}[center]{title}
        \includegraphics[height=64px]{res/tweag-io.pdf}
  \end{beamercolorbox}

  \begin{beamercolorbox}[center]{title}
    (A huge thank you to everyone at \texttt{tweag.io} who read the literature with me!)
  \end{beamercolorbox}
\end{frame}


\begin{frame}[allowframebreaks]{References}
        \bibliographystyle{amsalpha}
        \nocite{*}
        \bibliography{references.bib}
\end{frame}


\begin{frame}[fragile]{Use case: Bayesian updates}
\begin{code}
predictCoinBias :: [Int] -> Rand Double
predictCoinBias flips = do
  b <- sample01
  forM_ flips $ \f -> do
    -- | Maximum a posterior
    score $ if f == 1 then b else (1 - b)
  return $ b
\end{code}

\begin{code}
predictCoinBiasNoData :: Rand Double
predictCoinBiasNoData = predictCoinBias []
\end{code}

\input{"| cabal v2-exec slides -- predictCoinBiasNoData"}


\begin{code}
predictCoinBias0 :: Rand Double
predictCoinBias0 = predictCoinBias [0]
\end{code}

\input{"| cabal v2-exec slides -- predictCoinBias0"}

\begin{code}
predictCoinBias01 :: Rand Double
predictCoinBias01 = predictCoinBias [0, 1]
\end{code}

\input{"| cabal v2-exec slides -- predictCoinBias01"}

\end{frame}


\begin{frame}[fragile]{Use case: Sample from arbitrary distributions}

\begin{code}
sampleSinSq :: Rand Double
sampleSinSq = do
  x <- (6 *) <$> sample01
  score $ (sin x) * (sin x)
  return $ x
\end{code}

\input{"| cabal v2-exec slides -- sampleSinSq"}

\end{frame}




\end{document}


